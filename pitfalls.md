Pitfalls
===
Pitfalls encountered during developing Fly Management System recorded in reverse chronological order.

## Backend

- To handle a request of fetching a representation of a resource with some identifiers for the desired resource, we prefer to use GET with query parameters (in the URL). However, the identifiers may get too long and make the URL very long. To solve this, a GET with body could come to your mind but this is not a good idea:
  
    > A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.[1]

    Using PUT with request body is a widely accepted way of achieving this, although PUT requests are not defined as idempotent, leading to request retry hesitancy.[2][3]
    
    [1]:[RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-4.3.1)\
    [2]:https://stackoverflow.com/a/70157919
    [3]:https://stackoverflow.com/a/63190922

- For a general exception handler for some exception thrown at some controller class, a `@ControllerAdvice` annotated interface/class could be useful:

    ```java
    @ControllerAdvice
    public interface ServiceExceptionHandler {
        @ExceptionHandler(value = { EntityNotFoundException.class })
        default ResponseEntity<Object> handleException(EntityNotFoundException ex) {
            Logger logger = LoggerFactory.getLogger(this.getClass());

            StackTraceElement[] stackTrace = ex.getStackTrace();
            StackTraceElement location = stackTrace[0]; // last exception call site

            logger.error("Exception thrown at {}.{} @ Line {} - {}",
                    location.getClassName(),
                    location.getMethodName(),
                    location.getLineNumber(),
                    ex.getMessage());

            return ResponseEntity.notFound().build();
        }
    }
    ```

    Then we can just `implement` this interface in any controller to handle all `EntityNotFoundException`s thrown to this controller:

    ```java
    public class ApplicantController implements ServiceExceptionHandler {
        // methods and fields ...
    }
    ```

- Services should throw exceptions about the data items (e.g.,  `EntityNotFoundException`) instead of other types of exception (e.g., `ResponseStatusException`) in place. Controllers are those who should catch these exceptions and then rethrow or do something else with these exceptions.
- Conform to REST API is good.
- (Almost) always write Javadoc for interfaces, especially for the complicated ones.
- To ensure the `@PathVariable` parameters to be not null, `@NotNull` annotation can be used. It will cause a `400 Bad Request` response to be returned if in very rare cases, the annotated parameter is null.
- Using `Pagination` to sort data items is totally an overkill and confusing. Simply use `sorted()` on the stream can do it:
    
    ```java
    @GetMapping("/{applicantId}")
    public ResponseEntity<ApplicantDTO> getApplicantById(@PathVariable Long applicantId) {
        ApplicantDTO applicant = applicantService.getById(applicantId);
        log.info("Got applicant with id={}", applicantId);
        return ResponseEntity.ok(applicant);
    }
    ```

- A `Javadoc` in `IntelliJ` can be generated by typing `/**` to a new line above the function declaration and press <kbd>Enter</kbd>. The IDE auto-completes the doc comment skeleton.
- `@Autowired` annotations on individual fields in a class are warned by IDE as `Field injection is not recommended`. The more recommend way of doing this is autowiring the fields via constructor injection for its immutability, testability, explicit dependency contract, and avoiding null pointer exceptions (at run time). See this video [Dependency Injection, The Best Pattern](https://www.youtube.com/watch?v=J1f5b4vcxCQ) by CodeAesthetic for more detail. We can add `@Autowired` to the constructor, for example:
  
    ```java
    @Service
    public class ApplicantService {

        private final ApplicantRepository applicantRepository;
        private final SkillRepository skillRepository;
        private final ApplicantSkillRepository applicantSkillRepository;

        @Autowired
        public ApplicantService(
                ApplicantRepository applicantRepository,
                SkillRepository skillRepository,
                ApplicantSkillRepository applicantSkillRepository) {
            
            this.applicantRepository = applicantRepository;
            this.skillRepository = skillRepository;
            this.applicantSkillRepository = applicantSkillRepository;
        }

        // other methods and fields ...

    }
    ```

- In an entity class, `@GeneratedValue` with `strategy = GenerationType.AUTO` won't detect the corresponding sequence defined in the PostgreSQL database:
- 
    ```java
    @Entity
    public class Applicant {
        @Id
        @SequenceGenerator(strategy = GenerationType.AUTO)
        @Column(name = "id")
        private Long id;

        // other fields ...
    }
    ```

    running it will cause an error:

    ```java
    org.hibernate.engine.jdbc.spi.SqlExceptionHelper: ERROR: relation "hibernate_sequence" does not exist
    ```

    This is because `strategy = GenerationType.AUTO` tells `Hibernate` to use the default strategy to generate IDs, which is looking for a "hibernate_sequence" in PostgreSQL database. Instead, we can connect to the defined sequence:
    
    ```java
    public class Applicant {
        @Id
        @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "F_Applicant_id_seq_generator")
        @SequenceGenerator(name = "F_Applicant_id_seq_generator", sequenceName = "\"F_Applicant_id_seq\"", allocationSize = 1)
        @Column(name = "id")
        private Long id;

        // other fields ...
    }
    ```

    Tip: the `allocationSize` should be set to the `INCREMENT_BY` field of the corresponding sequence in the database. "If you set the allocationSize attribute to 50, you tell Hibernate that the sequence gets incremented by 50 and that it shall generate 49 values internally before it selects the next value from the sequence." This is beneficial in terms of performance for the case when a single database is accessed by multiple separate clients. See this [StackOverflow answer](https://stackoverflow.com/a/47992716/9438200) for more details.
- Following REST conventions, a POST api should return a `201 Created` HTTP response code with a `Location` header pointing to the URL of the newly created resource. For example:
    
    ```java
    @RestController
    public class ApplicantController {
        @PostMapping
        public ResponseEntity<Void> createApplicant(@RequestBody @Valid ApplicantDTO applicantDTO) {
            ApplicantDTO applicant = applicantService.create(applicantDTO);
            URI location = ServletUriComponentsBuilder.fromCurrentRequest()
                            .path("/{id}").buildAndExpand(applicant.getId()).toUri();

            log.info("New applicant with id={} is created", applicant.getId());
            return ResponseEntity.created(location).build();
        }
    }
    ```

- [Loggers]

## Frontend

## Misc
